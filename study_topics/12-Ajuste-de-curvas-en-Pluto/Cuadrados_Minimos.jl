### A Pluto.jl notebook ###
# v0.14.7

using Markdown
using InteractiveUtils

# This Pluto notebook uses @bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of @bind gives bound variables a default value (instead of an error).
macro bind(def, element)
    quote
        local el = $(esc(element))
        global $(esc(def)) = Core.applicable(Base.get, el) ? Base.get(el) : missing
        el
    end
end

# ‚ïî‚ïê‚ï° b0f07f70-709d-11eb-18c4-c3e18fe313b2
using Statistics, Plots, LsqFit, PlutoUI, LinearAlgebra, FileIO

# ‚ïî‚ïê‚ï° b20f440a-70b5-11eb-39f3-c7722d706c17
md"# Modelado de datos: *'Cuadrados m√≠nimos'*, *'Ajuste por funciones'*

Es la base de la ciencia de datos.

[Aqu√≠](https://drive.google.com/file/d/1E7Ou-wZtm4tuEnSKbMLmEY3HzXk8DUhv/view?usp=sharing) pueden encontrar un video explicativo"

# ‚ïî‚ïê‚ï° aa6199e4-f426-433a-ba1b-a1df01a9bf28
TableOfContents(title="üìö Contenido", indent=true, depth=4, aside=true)

# ‚ïî‚ïê‚ï° 96d389ac-711f-11eb-1ecc-b5539d6495cb
md"Dada dos series de datos, $\{x_i\}$ y $\{y_i\}$, queremos encontrar si hay una relaci√≥n entre ellos. Comenzaremos con el caso donde se busca una relaci√≥n lineal.
$y_i = a_1 + a_2 * x_i$. A modo de ejemplo contruiremos los datos empleando la relaci√≥n lineal con par√°metros dados sumandoles una componente peque√±a aleatoria.
La componente aleatoria tiene media de cero y $\sigma = 1$.

$$y_i = a_1 + a_2 * x_i + \epsilon Rand$$
Para corroborar esto √∫ltimo graficamos su histograma.
Para la variable independiente tomamos un conjunto equiespaciados de puntos.
"

# ‚ïî‚ïê‚ï° fe4f6088-709d-11eb-2e70-bf9c04887219
begin
	œµ = 0.1
	a1 = 1.
	a2 = 2.
	xdata = range(1, stop=3, length=200)
	ydata = a1 .+ a2 .* xdata+ œµ * randn(length(xdata))
	histogram(randn(length(xdata))
		#,size=(600,600)
	)
end

# ‚ïî‚ïê‚ï° 63a3a450-e541-4fc7-9f30-807614669afd
md"Ploteamos ahora los datos propuestos."

# ‚ïî‚ïê‚ï° 26958b94-709e-11eb-193c-abd32211f111
scatter(xdata,ydata, alpha = 0.5, frame_style=:origin, label="data points", leg=:topleft, xlabel="xdata", ylabel="ydata"
	#,size=(800,800)
)

# ‚ïî‚ïê‚ï° 928b9abb-b0c7-4d11-af75-29094f86ba21
md"Sumamos al gr√°fico la funci√≥n exacta por comparaci√≥n."

# ‚ïî‚ïê‚ï° dbae23a6-709e-11eb-255c-6b246a1d82d9
begin
	scatter(xdata,ydata, alpha = 0.5, frame_style=:origin, label="data points", leg=:topleft, xlabel="xdata", ylabel="ydata")
	plot!(xdata, a1 .+ a2 .* xdata, linewidth = 4,
		label="ajustados"
		#,size=(800,800)
		)	
end

# ‚ïî‚ïê‚ï° 1e3c30cc-7122-11eb-12b0-3b2aa0953ac2
md"## Encontrando los par√°metros"

# ‚ïî‚ïê‚ï° 239adf24-7121-11eb-1db9-df285eef255c
md"La idea ahora es reencontrar los par√°metros $(a1,a2)$ a partir de los dados, $(xdata,ydata)$. Para simplificar la b√∫squeda de estos par√°metros eliminamos uno de ellos trasladando los datos de manera que los promedios de ambos datos sean nulos. 
Es decir, definimos nuevos datos como $xdata_0 = xdata - <xdata>$, etc. Donde $<>$ significa tomar el promedio. De esa forma, en las nuevas variables la relaci√≥n ser√° del tipo $y_i = a_2 x_i$. Luego de encontrar $a_2$ es simple reconstituir las variables originales y obtener $a_1$ usando la igualdad con los promedios."

# ‚ïî‚ïê‚ï° a05cabe0-70a0-11eb-3a6f-13a03b009f10
begin
	
		x_s = xdata .- sum(xdata)/length(xdata)
		y_s = ydata .- sum(ydata)/length(ydata)
		scatter(x_s,y_s, alpha = 0.5, frame_style=:origin, label="data points", leg=:topleft, xlabel="xdata", ylabel="ydata")
		plot!(x_s, a2 .* x_s, linewidth = 4
		,label="ajuste"
		#,size=(800,800)
	)
end

# ‚ïî‚ïê‚ï° 280d122c-7ddb-4894-bb0a-416479a7f3cf


# ‚ïî‚ïê‚ï° 5f4db12c-a714-4a7f-a9fa-1c8d9f9e85ee
md"Utilizaremos tres formas de encontrar los par√°metros en orden de sofisticaci√≥n: "

# ‚ïî‚ïê‚ï° 4c36082a-1f51-45d0-acb1-eb2db73b9ced
md"### Ajuste gr√°fico. 
Trazamos rectas que pasan por el origen con distintas pendientes y vemos cual aproxima mejor nuestros datos. Para ello generamos un Slider que nos da distintos valores para los par√°metros.
"

# ‚ïî‚ïê‚ï° 42ca4316-70a0-11eb-2bae-fbc5b3472332
@bind aa Slider(-1:0.2:4; default=2, show_value=true)

# ‚ïî‚ïê‚ï° 77b6fb56-709f-11eb-3116-3fe183335bcc
begin
	scatter(x_s,y_s, alpha = 0.5, frame_style=:origin, label="data points", leg=:topleft, xlabel="xdata", ylabel="ydata")
	plot!(x_s, aa .* x_s, linewidth = 4
		#,size=(800,800)
		,label="ajuste"
	)
end

# ‚ïî‚ïê‚ï° a39ffdd4-7122-11eb-30bd-13b8618ed938
md"### Ajuste anal√≠tico / gr√°fico.

Definimos una funci√≥n distancia entre los puntos datos y distintas rectas y buscamos su m√≠nimo. Para ello usamos la distancia Eucl√≠dea. Vemos a simple vista que el m√≠nimo esta justamente para el valor del par√°metro fijado en los datos. 
" 

# ‚ïî‚ïê‚ï° 555d69bd-13d8-4902-a785-3d19a876c8cd
md"Para ello definimos una funci√≥n distancia, la diferencia entre los puntos medidos y los obtenidos a partir del modelo."

# ‚ïî‚ïê‚ï° 066ccf32-70a1-11eb-2264-c1d98968804f
function distance(a, x, y)
	return sqrt((y .- a .*x)'*(y .- a .*x))/length(x)
	#return sqrt(sum.((y .- a .*x).^2)) 
end

# ‚ïî‚ïê‚ï° 4682e8e0-70a1-11eb-0963-078eee9410e4
distance(2, x_s, y_s);

# ‚ïî‚ïê‚ï° 0c1f3ecd-80ad-4f55-998c-b35d2b0a61f3
begin
	r = range(-1., stop=2*a2, length = 200)
	s = [distance(x, x_s, y_s) for x ‚àà r]
end

# ‚ïî‚ïê‚ï° 69b258be-70a1-11eb-08bf-2bf580c6a1e8
begin
	plot(r,s
		,lw=3
		,label="funci√≥n distancia"
		#,size=(1000,1000)
	)
end

# ‚ïî‚ïê‚ï° 56c40a90-7123-11eb-33e3-09d683e8978b
md" Vemos a simple vista que el m√≠nimo est√° cercano al valor 2. Usando la funci√≥n findmin() podemos ajustar el resultado a un valor m√°s preciso. Para ello evaluamos la funci√≥n distancia en muchos puntos uniformente distribuidos del par√°metro y buscamos el lugar donde el vector de estas cantidades es m√≠nimo y con el encontramos el par√°metro. " 

# ‚ïî‚ïê‚ï° 9af192c8-711e-11eb-002f-df71037526be
r[findmin(s)[2]]

# ‚ïî‚ïê‚ï° 2dba09b2-70a4-11eb-0cc4-c9c479db808a
md"### Ajuste Anal√≠tico.

Calculamos el m√≠nimo de la funci√≥n distancia.

Para mayor generalidad volvemos al problema original (sin trasladarlos). 
Dado los datos xdata y ydata tenemos una distancia, funci√≥n de dos par√°metros, $[p_1, p_2]$, 

$d(p_1,p_2)^2 = \sum_i (y_i - (p_1 + p_2 * x_i))^2$

Esta es una funci√≥n cuadr√°tica en $p_1$ y $p_2$, y por lo tanto suave. 
Usamos aqu√≠ el cuadrado de la distancia pues el m√≠nimo coincide con el de su cuadrado y es m√°s simple para trabajar, adem√°s es suave incluso cuando la distancia se anula. Su m√≠nimo estar√° en el √∫nico punto donde su derivada se anula con respecto a cada uno de los par√°metros:

$\partial_{p_1} d(p_1,p_2) = \partial_{p_2} d(p_1,p_2) = 0$

Desarrollando los cuadrados y sumando vemos que:

$$d(p_1,p_2)^2 = \sum_i [y_i^2 - 2 y_i (p_1 + p_2 * x_i) + (p_1 + p_2 * x_i)^2]$$

$$= \sum_i (y_i^2) + p_1^2 * N   - 2p_1 \sum_i y_i + 2p_1 p_2 \sum_i x_i + p_2^2 \sum_i x_i^2 - 2p_2\sum y_ix_i$$
$$= <y^2> + p_1(b*<1> - 2<y> + 2p_2<x>) + p_2(p_2 <x^2> - 2<xy>)$$,

donde, $<s> := \frac{1}{N}\sum_i^N s_i$.

Por lo tanto,

$$\partial_{p_1} d(p_1,p_2)^2 = 2p_1 - 2<y> + 2p_2 <x>$$


y 

$$\partial_{p_2} d(p_1,p_2)^2 = 2p_1 <x> + 2p_2<x^2> - 2<xy>$$.

Resolvemos el sistema $2 \times 2$ para $(p_1, p_2)$.

"



# ‚ïî‚ïê‚ï° ce363d5b-cc20-4941-80fc-432f01647b06
md"Lo resolvemos usando la biblioteca de √°lgebra lineal de Julia"

# ‚ïî‚ïê‚ï° dd12fc25-a074-4c8c-9dd1-ddaa643c235b
md"Probamos el algoritmo con el ejemplo anterior, pero permitimos que los par√°metros var√≠en."

# ‚ïî‚ïê‚ï° da4eacad-8f47-4ed8-87d7-4a174310dbd7
md"Cambiamos los par√°metros con los que creamos el dato y vemos que los par√°metros cambian de forma que el ajuste es nuevamente bueno."

# ‚ïî‚ïê‚ï° 8d22abc2-70b1-11eb-0b52-2d05ad1ba312
@bind p2 Slider(-3:6; default = 2, show_value=true)

# ‚ïî‚ïê‚ï° e9d629e0-70b1-11eb-213a-5d609433e4de
@bind p1 Slider(-2:4; default = 1, show_value=true)

# ‚ïî‚ïê‚ï° d4756f70-f4bc-40c7-bccd-3dca4242b440
begin
	#œµ = 0.1
	#p1 = 1.
	#p2 = 2.
	xdata_1 = range(1, stop=3, length=200)
	ydata_1 = p1 .+ p2 .* xdata+ œµ * randn(length(xdata_1))
	#histogram(randn(length(xdata)))
end

# ‚ïî‚ïê‚ï° ebfefe88-70a8-11eb-1969-a3ae75cf72cc
begin
	A = zeros(2,2)
	f = zeros(2)
	N = ones(length(xdata))
	A[1,1] = 1
	A[1,2] = xdata_1'*N / length(xdata_1)
	A[2,1] = A[1,2]
	A[2,2] = xdata_1'*xdata_1 / length(xdata_1)
	
	f[1] = ydata_1'*N  / length(xdata_1)
	f[2] = xdata_1'*ydata_1 / length(xdata_1)
end

# ‚ïî‚ïê‚ï° ccc82b18-70b0-11eb-112d-a503d66b6b33
p = f' / A

# ‚ïî‚ïê‚ï° 333cf37e-70b1-11eb-1616-63d971f03a66
begin
	scatter(xdata_1,ydata_1, alpha = 0.5, frame_style=:origin, label="data points", leg=:topleft, xlabel="xdata", ylabel="ydata")
	plot!(xdata_1, p[1].+ p[2].*xdata_1 ,  linewidth = 4
		,label="ajuste"
		#,size=(1000,1000)
	)
end

# ‚ïî‚ïê‚ï° e0be0184-70b4-11eb-2025-091a431f9c07
e = sqrt(sum((ydata - p[1].*xdata .+ p[2]).^2))/length(xdata);

# ‚ïî‚ïê‚ï° 2452d0fe-70b4-11eb-1682-fddd1a7dd41d
md" El error en la aproximaci√≥n del ajuste de cuadrados m√≠nimos se expresa como la distancia dividida por el n√∫mero de puntos, es decir:

``
e = \frac{ \sqrt{\sum^N_i (y_i - (p_1 + p_2*x_i)^2)} }{N} = 
``
=$(e)
"

# ‚ïî‚ïê‚ï° dc1955f0-f35b-46e5-8529-4c470670842b
md"!!! note 
Falta error en los par√°metros!
"

# ‚ïî‚ïê‚ï° 5d997418-70b5-11eb-05f9-37cd5c59276b
md"# Ajuste por funciones no lineales
Ahora vamos a emplear un paquete de Julia, **LsqFit**, para encontrar fiteos muy generales a conjuntos de datos. 

Primero repetiremos la cuenta con el fiteo lineal y luego veremos uno no lineal.

Para usar el paquete debemos definir un *modelo*, que es simplemente la funci√≥n que proponemos para aproximar los datos, la cual depender√° de par√°metros libres que iremos ajustando de acuerdo a los datos presentes. Adem√°s debemos dar algunos valores iniciales de estos par√°metros. La distancia se va minimizando a partir de un algoritmo de minimizaci√≥n iterativo conocido como *Levenberg Marquardt*.

Para el caso lineal ya trabajado proponemos entonces: 
"

# ‚ïî‚ïê‚ï° 095d3f68-709e-11eb-0e5c-d987f6a027e7
begin
	p0 = [0.5, 0.5]
	@. model(x, p) = p[1] + x*p[2]
end

# ‚ïî‚ïê‚ï° 65605e72-70ca-11eb-2442-1b524e2a3be3
begin
	fit = curve_fit(model, xdata, ydata, p0);
	fit.param
end

# ‚ïî‚ïê‚ï° 8357e8f8-7126-11eb-1853-19050526a4fe
md"Adem√°s de los par√°metros encontrados la variable fit tiene m√°s informaci√≥n, como por ejemplo la matriz de covarianza, la cual nos da un error estad√≠stico para los par√°metros. Para ver los significados de estas estimaciones de error es preciso conocer un poco m√°s de estad√≠stica." 

# ‚ïî‚ïê‚ï° 10167b44-70cb-11eb-18aa-cfb3b8bf7892
cov = estimate_covar(fit)

# ‚ïî‚ïê‚ï° 346f04c0-70cb-11eb-3bd9-7ba4d985e0a2
#se = standard_error(fit)
#se = sqrt(cov)
sqrt(Diagonal(cov))

# ‚ïî‚ïê‚ï° 70d205fc-70cb-11eb-1f96-4f1df265c5f5
margin_of_error = margin_error(fit, 0.1)

# ‚ïî‚ïê‚ï° b02c7046-7127-11eb-34e6-0f3a88b50127
confidence_intervals = confidence_interval(fit, 0.1)

# ‚ïî‚ïê‚ï° b3827416-70cd-11eb-0c47-5b98b59dd367
md"## Un caso no lineal"

# ‚ïî‚ïê‚ï° cbe333c4-70cd-11eb-2b1a-31f730411017
begin
	@. model_nl(x, p) = p[1]*exp(x*p[2])
	#ydata_nl = zeros(length(xdata))
	ydata_nl = model_nl(xdata .+ œµ .*rand(length(xdata)), [4.0, -2.0])  .+ 0.2 .* œµ .*rand(length(xdata))
end

# ‚ïî‚ïê‚ï° ef2e998e-70cf-11eb-0624-ad174268eeea
scatter(xdata, ydata_nl, alpha = 0.5, label="data points", leg=:topleft, xlabel="xdata", ylabel="ydata"
	#,size=(1000,1000)
)

# ‚ïî‚ïê‚ï° 371abd68-70d0-11eb-2f08-1f554c7610e6
fit_nl = curve_fit(model_nl, xdata, ydata_nl, p0); fit_nl.param

# ‚ïî‚ïê‚ï° 6d72f29a-70d0-11eb-14dd-3beaf78a77e1
begin
	scatter(xdata, ydata_nl, alpha = 0.5, label="data points", leg=:topleft, xlabel="xdata", ylabel="ydata")
	plot!(xdata, model_nl(xdata,fit_nl.param), linewidth = 3
		#,size=(1000,1000)
	)
end

# ‚ïî‚ïê‚ï° 196d6940-70d1-11eb-1606-af5fbff749de
begin
	cov_nl = estimate_covar(fit_nl)
	se = sqrt(Diagonal(cov_nl))
end

# ‚ïî‚ïê‚ï° 8e46004a-7128-11eb-3d15-f18f02ff47e2
md"## Ejercicio

Para este ejercicio mostramos primero como obtener datos de un archivo (previamente producido) con datos para hacer un ajuste.

!!! Note

Aqu√≠ usamos el formato propio de Julia, `JLD2`, que es muy conveniente. Si sus archivos est√°n en el formato CSV (*Comma Separate Values*) puede usar la librer√≠a `CVS` como se indica m√°s abajo.
"

# ‚ïî‚ïê‚ï° 2df5f59c-7134-11eb-39c2-b753c2903d61
tide = load(download("https://gitlab.com/oreula/julia_examples/-/raw/master/Cuadrados_Min/tide_data.jld2"),"tide")

# ‚ïî‚ïê‚ï° 65774492-7134-11eb-35c2-39817e784ae1
begin
	xt = tide[1,:]
	yt = tide[2,:]
	scatter(xt,yt
		#,size=(1000,1000)
	)
end

# ‚ïî‚ïê‚ï° 8e2dca94-7140-11eb-23db-07081a2000eb
md"Use la librer√≠a ya introducida para proponer un modelo para estos datos y encuentre los par√°metros correctos. Puede primero hacerlo moviendo manualmente los par√°metros y graficando el modelo sobre los datos."

# ‚ïî‚ïê‚ï° 54731b59-85e0-442a-b23b-47c99f0bebe3
md"
Para usar la librer√≠a CSV seleccione aqu√≠ $(@bind allow_csv CheckBox())"

# ‚ïî‚ïê‚ï° 4cbd5d1a-d93a-451a-b5c6-0912991b1587
if allow_csv
using CSV #coma separated values
using DataFrames
#using Plots
url_1 = "https://raw.githubusercontent.com/reula/MetodosNumericos2021/main/Guias/mediciones1-c1-g6.dat"
url_2="https://gitlab.com/oreula/julia_examples/-/raw/master/Cuadrados_Min/mediciones1-c1-g6.dat"
a_1 = CSV.read(download(url_2), DataFrame, header=["x", "y"], delim=" ", ignorerepeated=true)
scatter(a_1.x,a_1.y)
plot!(a_1.x,a_1.y)
plot!(xlim=(0,0.1))
end

# ‚ïî‚ïê‚ï° 01de4d62-0d47-4423-afd2-42abcec683db
md"## Malos ejemplos:

El m√©todo de ajuste funciona bien para casos donde la funci√≥n distancia tiene pocos m√≠nimos y ninguno cercano al m√≠nimo absoluto (en el caso que no partamos muy lejos de ella).

Ahora veremos un ejemplo donde las cosas no son tan lindas. Este es el ejemplo que est√° en: 

[Levenberg-Marquardt-Wikipedia](https://en.wikipedia.org/wiki/Levenberg%E2%80%93Marquardt_algorithm)

y se refiere al algorithmo usado por la librer√≠a, llamado **Levenberg-Marquardt**.
"

# ‚ïî‚ïê‚ï° ebc60504-142c-48f6-a9d6-19745d78600c
md" Se trata de aproximar la funci√≥n $ce(x) = a*cos(bx) + b*sin(ax)$ con $a=100$ y $b=102$"

# ‚ïî‚ïê‚ï° 4cd57c56-f8d8-4558-b8e4-073c7c7ee710
ce(x,A,B) = A*cos(B*x) + B*sin(A*x)

# ‚ïî‚ïê‚ï° 14be3370-bf92-4e61-95f0-431d10b6cd71
md"Aqu√≠ graficamos la funci√≥n con una peque√±a parturbaci√≥n al azar."

# ‚ïî‚ïê‚ï° 0bcf6839-4f65-4dd1-bf4d-10451b3d0a2b
begin
	x=0:0.01:100; y=ce.(x,100,102) + 0.01 *rand(length(x))
	#scatter(x,y)
	plot(x,y)
end

# ‚ïî‚ïê‚ï° c74dbb79-3062-4a53-a83e-512ce9a026e9
md"Generamos el modelo y lo aplicamos:"

# ‚ïî‚ïê‚ï° c83bb2a1-b0bd-4eca-a5f1-65b40c893be5
begin
	@. model_ce(x, p) = p[1]*cos(p[2]*x) + p[2]*sin(p[1]*x)
	pce = [90.; 90.]
	fit_ce = curve_fit(model_ce, x, y, pce); fit_ce.param
end

# ‚ïî‚ïê‚ï° 48d7b13e-af57-403f-8573-845178285be3
begin
	cov_ce = estimate_covar(fit_ce)
	se_ce = sqrt(Diagonal(cov_ce))
end

# ‚ïî‚ïê‚ï° 2ae0962e-dcbf-4861-8cf7-58e3a399943b
md"Vemos que el algoritmo encuentra un ajuste totalmente distinto! Y dem√°s nos dice que es bueno! Ha encontrado otro m√≠nimo."

# ‚ïî‚ïê‚ï° caf89481-80f3-471d-9e1d-d9c02ff28551
begin
	xce = 0:0.1:10
	plot(x[1:100],y[1:100],label="Exacta")
	plot!(x[1:100],model_ce(x[1:100],fit_ce.param),label="Ajuste")
end

# ‚ïî‚ïê‚ï° 6168aa5b-b294-4573-aacd-3f5073d195c6
md" Para comprender el problema graficamos la funci√≥n distancia para este caso:
(usamos una funci√≥n distancia normalizada con los datos a los prop√≥sitos de los gr√°ficos)"

# ‚ïî‚ïê‚ï° dc978b95-5dbd-4530-bc06-62bd11eed368
	d_ce(p1,p2) = sqrt(sum((y - model_ce(x, [p1;p2])).^2))/sqrt(sum(y.^2))

# ‚ïî‚ïê‚ï° d7135bba-42a4-47c8-b9c3-2d19d8622464
begin
	begin
	p_ce_1f = 60:0.1:110;
	p_ce_2f = 60:0.1:110;
end
	#levels = 1.:0.01:1.3
	#heatmap(p_ce_1f, p_ce_2f, d_ce
	contour(p_ce_1f, p_ce_2f, d_ce
		, fill = true
		, levels = 20
		, c = cgrad(:beach)
		#,contour_labels = true
	)
end

# ‚ïî‚ïê‚ï° cca37f6f-7811-45cd-92ff-65bb18692da6
md"Para ver las im√°genes que siguen seleccione aqu√≠ $(@bind allow_run CheckBox())
tenga en cuenta que los c√°lculos necesarios son pesados"

# ‚ïî‚ïê‚ï° 1ea85398-a498-423f-8cff-4962496168c9
if allow_run
@bind init_par Slider(1:100; default = 98, show_value=true)
end

# ‚ïî‚ïê‚ï° b953e14a-f966-484a-a572-546bf28c0fbf
if allow_run
@bind final_par Slider(100.1:110; default = 104, show_value=true)
end

# ‚ïî‚ïê‚ï° 02179573-efde-49a7-bb78-248ffcfb4649
if allow_run
	p_ce_1 = init_par:(final_par-init_par)/50:final_par;
	#p_ce_2 = init_par:1.:final_par;
	p_ce_2 = init_par:(final_par-init_par)/50:final_par;
end

# ‚ïî‚ïê‚ï° 9a56a29d-5408-47af-814a-9ab27db1c200
if allow_run
	#levels = 1.:0.01:1.3
	contour(p_ce_1, p_ce_2, d_ce
		, fill = true
		, levels = 10
		, c = cgrad(:beach)
		#,contour_labels = true
	)
end

# ‚ïî‚ïê‚ï° 92f836b0-c1f0-4a96-8131-f8a20790183b
md" Vemos que el problema es que hay ca√±adones muy estrechos con m√≠nimos locales. El algoritmo para pues llega a condiciones que corresponden a m√≠nimos locales." 

# ‚ïî‚ïê‚ï° 5c84c0fe-887e-40fe-aff5-bed7789c22ef
begin
	allow_run_hm=false
	if allow_run_hm
		#levels = 1.:0.01:1.3
		heatmap(p_ce_1, p_ce_2, d_ce
			#, fill = true
			#, levels = 10
			, c = cgrad(:beach)
			#,contour_labels = true
		)
	end
end

# ‚ïî‚ïê‚ï° Cell order:
# ‚ïü‚îÄb20f440a-70b5-11eb-39f3-c7722d706c17
# ‚ï†‚ïêb0f07f70-709d-11eb-18c4-c3e18fe313b2
# ‚ïü‚îÄaa6199e4-f426-433a-ba1b-a1df01a9bf28
# ‚ïü‚îÄ96d389ac-711f-11eb-1ecc-b5539d6495cb
# ‚ïü‚îÄfe4f6088-709d-11eb-2e70-bf9c04887219
# ‚ïü‚îÄ63a3a450-e541-4fc7-9f30-807614669afd
# ‚ïü‚îÄ26958b94-709e-11eb-193c-abd32211f111
# ‚ïü‚îÄ928b9abb-b0c7-4d11-af75-29094f86ba21
# ‚ïü‚îÄdbae23a6-709e-11eb-255c-6b246a1d82d9
# ‚ïü‚îÄ1e3c30cc-7122-11eb-12b0-3b2aa0953ac2
# ‚ïü‚îÄ239adf24-7121-11eb-1db9-df285eef255c
# ‚ïü‚îÄa05cabe0-70a0-11eb-3a6f-13a03b009f10
# ‚ïü‚îÄ280d122c-7ddb-4894-bb0a-416479a7f3cf
# ‚ïü‚îÄ5f4db12c-a714-4a7f-a9fa-1c8d9f9e85ee
# ‚ïü‚îÄ4c36082a-1f51-45d0-acb1-eb2db73b9ced
# ‚ïü‚îÄ77b6fb56-709f-11eb-3116-3fe183335bcc
# ‚ïü‚îÄ42ca4316-70a0-11eb-2bae-fbc5b3472332
# ‚ïü‚îÄa39ffdd4-7122-11eb-30bd-13b8618ed938
# ‚ïü‚îÄ555d69bd-13d8-4902-a785-3d19a876c8cd
# ‚ï†‚ïê066ccf32-70a1-11eb-2264-c1d98968804f
# ‚ïü‚îÄ4682e8e0-70a1-11eb-0963-078eee9410e4
# ‚ïü‚îÄ69b258be-70a1-11eb-08bf-2bf580c6a1e8
# ‚ï†‚ïê0c1f3ecd-80ad-4f55-998c-b35d2b0a61f3
# ‚ïü‚îÄ56c40a90-7123-11eb-33e3-09d683e8978b
# ‚ï†‚ïê9af192c8-711e-11eb-002f-df71037526be
# ‚ïü‚îÄ2dba09b2-70a4-11eb-0cc4-c9c479db808a
# ‚ï†‚ïêebfefe88-70a8-11eb-1969-a3ae75cf72cc
# ‚ïü‚îÄce363d5b-cc20-4941-80fc-432f01647b06
# ‚ï†‚ïêccc82b18-70b0-11eb-112d-a503d66b6b33
# ‚ïü‚îÄdd12fc25-a074-4c8c-9dd1-ddaa643c235b
# ‚ïü‚îÄd4756f70-f4bc-40c7-bccd-3dca4242b440
# ‚ï†‚ïê333cf37e-70b1-11eb-1616-63d971f03a66
# ‚ïü‚îÄda4eacad-8f47-4ed8-87d7-4a174310dbd7
# ‚ïü‚îÄ8d22abc2-70b1-11eb-0b52-2d05ad1ba312
# ‚ïü‚îÄe9d629e0-70b1-11eb-213a-5d609433e4de
# ‚ïü‚îÄ2452d0fe-70b4-11eb-1682-fddd1a7dd41d
# ‚ï†‚ïêe0be0184-70b4-11eb-2025-091a431f9c07
# ‚ïü‚îÄdc1955f0-f35b-46e5-8529-4c470670842b
# ‚ïü‚îÄ5d997418-70b5-11eb-05f9-37cd5c59276b
# ‚ï†‚ïê095d3f68-709e-11eb-0e5c-d987f6a027e7
# ‚ï†‚ïê65605e72-70ca-11eb-2442-1b524e2a3be3
# ‚ïü‚îÄ8357e8f8-7126-11eb-1853-19050526a4fe
# ‚ï†‚ïê10167b44-70cb-11eb-18aa-cfb3b8bf7892
# ‚ï†‚ïê346f04c0-70cb-11eb-3bd9-7ba4d985e0a2
# ‚ï†‚ïê70d205fc-70cb-11eb-1f96-4f1df265c5f5
# ‚ï†‚ïêb02c7046-7127-11eb-34e6-0f3a88b50127
# ‚ïü‚îÄb3827416-70cd-11eb-0c47-5b98b59dd367
# ‚ï†‚ïêcbe333c4-70cd-11eb-2b1a-31f730411017
# ‚ïü‚îÄef2e998e-70cf-11eb-0624-ad174268eeea
# ‚ï†‚ïê371abd68-70d0-11eb-2f08-1f554c7610e6
# ‚ïü‚îÄ6d72f29a-70d0-11eb-14dd-3beaf78a77e1
# ‚ï†‚ïê196d6940-70d1-11eb-1606-af5fbff749de
# ‚ïü‚îÄ8e46004a-7128-11eb-3d15-f18f02ff47e2
# ‚ï†‚ïê2df5f59c-7134-11eb-39c2-b753c2903d61
# ‚ïü‚îÄ65774492-7134-11eb-35c2-39817e784ae1
# ‚ïü‚îÄ8e2dca94-7140-11eb-23db-07081a2000eb
# ‚ïü‚îÄ54731b59-85e0-442a-b23b-47c99f0bebe3
# ‚ï†‚ïê4cbd5d1a-d93a-451a-b5c6-0912991b1587
# ‚ïü‚îÄ01de4d62-0d47-4423-afd2-42abcec683db
# ‚ïü‚îÄebc60504-142c-48f6-a9d6-19745d78600c
# ‚ï†‚ïê4cd57c56-f8d8-4558-b8e4-073c7c7ee710
# ‚ï†‚ïê14be3370-bf92-4e61-95f0-431d10b6cd71
# ‚ï†‚ïê0bcf6839-4f65-4dd1-bf4d-10451b3d0a2b
# ‚ïü‚îÄc74dbb79-3062-4a53-a83e-512ce9a026e9
# ‚ï†‚ïêc83bb2a1-b0bd-4eca-a5f1-65b40c893be5
# ‚ï†‚ïê48d7b13e-af57-403f-8573-845178285be3
# ‚ïü‚îÄ2ae0962e-dcbf-4861-8cf7-58e3a399943b
# ‚ïü‚îÄcaf89481-80f3-471d-9e1d-d9c02ff28551
# ‚ïü‚îÄ6168aa5b-b294-4573-aacd-3f5073d195c6
# ‚ï†‚ïêdc978b95-5dbd-4530-bc06-62bd11eed368
# ‚ï†‚ïêd7135bba-42a4-47c8-b9c3-2d19d8622464
# ‚ïü‚îÄcca37f6f-7811-45cd-92ff-65bb18692da6
# ‚ïü‚îÄ1ea85398-a498-423f-8cff-4962496168c9
# ‚ïü‚îÄb953e14a-f966-484a-a572-546bf28c0fbf
# ‚ïü‚îÄ02179573-efde-49a7-bb78-248ffcfb4649
# ‚ïü‚îÄ9a56a29d-5408-47af-814a-9ab27db1c200
# ‚ïü‚îÄ92f836b0-c1f0-4a96-8131-f8a20790183b
# ‚ïü‚îÄ5c84c0fe-887e-40fe-aff5-bed7789c22ef
